---
title: 观察者模式
date: 2018-07-26 11:25:10
categories: 设计模式
tags: [设计模式]
toc: true
comments: true
---

## 需求

笔者从事java两年里，经常听到这样的需求: “你这里改了，要告诉我们的服务啊，不然我们的数据就不是最新的”

这是一个很常见的需求，目前听过的解决方案大概有这么几种：

* A发生改变时，主动调用B的接口，同步数据，但是想想如果有很多个B服务，你要调用多少次？
	
* 数据发现改变，本质上是在数据库中改变的，可以用触发器实现，但是不同的数据库实现不同，
	限制很多，对性能也有一定的影响，就拿常用的MySQL来说，基于行触发的触发器，在大批量数据更新时，效率极低
	
* 使用消息中间件，比如我司最爱用的Kafka，使用异步方式解耦
	
消息中间件最简单的模型：生产者往topic里生产一条数据，告诉Kafka，订阅了这个topic的消费者立即消费做出响应

## 观察者模式

再往简单里说说**观察者模式**，只要理解它的基本原理，代码一目了然

1. 首先明确有两个概念，观察者，被观察者，我更喜欢理解为监视器和目标
2. 目标维护一个列表，里面记录了注册过的监视器，对外提供注册列表的添加和移除api
3. 目标发生改变时，遍历这个列表里的所有监视器，通过调用监视器的一个方法通知监视器

## 使用场景
	
观察者模式的使用场景

1. 当一个对象改变，需要同时改变其它对象，但是却不知道具体多少对象有待改变
2. 当一个对象必须通知其它对象，但是却不知道具体对象到底是谁。换句话说，你不希望这些对象
	是紧密耦合的。
	
## 代码思路

原理并不难，可以说十分简单，两个类，注册列表用一个List集合表示，是否发生改变用一个布尔值表示，很容易手写出来，那么为什么用JDK自带的Observable(被观察者)，Observer(观察者)呢？

点开Observable的源码，since JDK1.0就有的一个类，十分古老，所以出现Vector也不足为奇了，再看里面的方法，关于修改Vector和changed的地方都被synchronized修饰，说明JDK对线程安全性考虑的很好

## JDK源码

Observable类中用于通知观察者的源码如下：

```
public void notifyObservers(Object arg) {
        Object[] arrLocal;
        /**
         * 自己翻译了下注释：我们不希望观察者在处理自己的监视器时，
         * 回调到所有的代码。我们从集合里取出每一个被观察者，并且
         * 存储观察者的需要同步的状态，但是不应该通知观察者们。
         * 任意竞争锁的最糟糕结果是
         *  1.一个新增的观察者可能错过通知
         *  2.一个最近注销的观察者在它不需要的时候被通知了
         */
        synchronized (this) {
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }

        for (int i = arrLocal.length - 1; i >= 0; i--)
            ((Observer) arrLocal[i]).update(this, arg);
    }
```
流程很简单：

1. 判断标志位是否为已改变
2. 集合转为数组，然后重置标志位为false
3. 遍历每一个观察者，调用方法
	
## 代码实现

代码实现观察者模式:主要想表达的是Name发生改变时，通知到观察者

### Step 1: 被观察者

继承Observable

```
public class Target extends Observable {
    private String name;

    public void setName(String name) {
        this.name = name;
        this.setChanged();
        this.notifyObservers("name has been changed, now is " + name);
    }
    
    public String getName() {
        return name;
    }
}
```

### Step 2: 观察者

观察者实现Observer接口，里面只有一个update方法，可以说是一个函数式接口，读者可以回看一下源码中的这一段，应该知道这个方法的作用了，这是观察者对被观察者通知做出的反应

```
((Observer) arrLocal[i]).update(this, arg);
```

```
public class Watcher implements Observer {
   @Override
    public void update(Observable o, Object arg) {
        Target target = (Target) o;
        System.out.println("I am be notified by " + target.getName() + ", message is " + arg);
    }}
```
### Step 3: 验证

```
public static void main(String[] args) {
        Target target = new Target();

        Watcher foo = new Watcher();
        Watcher bar = new Watcher();

        target.addObserver(foo);
        target.addObserver(bar);

        target.setName("Jim");

        target.deleteObserver(bar);
        target.setName("Kim");
    }
```
### 控制台输出

```
I am be notified by Jim, message is name has been changed, now is Jim
I am be notified by Jim, message is name has been changed, now is Jim
I am be notified by Kim, message is name has been changed, now is Kim

```

### 结论

	
1. 第一次setName通知了两个观察者，然后移除了bar观察者，下一次通知就只有一个观察者收到了
2. 现在想想以前用过的vue，应该也使用到了观察者模式

## 心得

```	
Java中解耦是很重要的一件事，小到类，大到多个系统，以我愚见，都是一种思想

增加一个中间层，可以是一个接口，一个变量，一个中间件，一份文件，
这个中间层有很多名词，注册中心，负载均衡，代理，委托
```


