---
title: 观察者模式
date: 2018-07-26 11:25:10
categories: 设计模式
tags: [设计模式]
toc: true
comments: true
---

## 使用场景
    
一个对象的属性发生改变时，需要通知到依赖它的对象，使其做出反应

## 实现原理

针对使用场景，如何用代码去实现这种效果，只要理解了观察者模式的基本原理，代码一目了然

1. 首先明确有两个对象: 观察者，被观察者，我更喜欢理解为监视器和目标
2. 目标对象里维护一个注册列表，里面记录了注册过的监视器，对外提供注册列表的添加和移除api
3. 目标发生改变时，遍历这个列表里的所有监视器，通过调用监视器的一个方法通知监视器
	
## 代码思路

原理并不难，可以说十分简单，两个类，注册列表用一个List集合表示，是否发生改变用一个布尔值表示，很容易手写出来，那么为什么要用JDK自带的Observable(被观察者)，Observer(观察者)呢？

点开Observable的源码，since JDK1.0就有的一个类，十分古老，所以出现Vector也不足为奇了，再看里面的方法，关于修改Vector和changed的地方都被synchronized修饰，说明JDK对线程安全性考虑的很好

## JDK源码

Observable类中用于通知观察者的源码如下：

```
public void notifyObservers(Object arg) {
        Object[] arrLocal;
        /**
         * 自己翻译了下注释：我们不希望观察者在处理自己的监视器时，
         * 回调到所有的代码。我们从集合里取出每一个被观察者，并且
         * 存储观察者的需要同步的状态，但是不应该通知观察者们。
         * 任意竞争锁的最糟糕结果是
         *  1.一个新增的观察者可能错过通知
         *  2.一个最近注销的观察者在它不需要的时候被通知了
         */
        synchronized (this) {
            if (!changed)
                return;
            arrLocal = obs.toArray();
            clearChanged();
        }

        for (int i = arrLocal.length - 1; i >= 0; i--)
            ((Observer) arrLocal[i]).update(this, arg);
    }
```
流程很简单：

1. 判断标志位是否为已改变
2. 集合转为数组，然后重置标志位为false
3. 遍历每一个观察者，调用方法
	
## 代码实现

代码实现观察者模式:主要想表达的是Name发生改变时，通知到观察者

### Step 1: 被观察者

继承Observable

```
public class Target extends Observable {
    private String name;

    public void setName(String name) {
        this.name = name;
        this.setChanged();
        this.notifyObservers("name has been changed, now is " + name);
    }
    
    public String getName() {
        return name;
    }
}
```

### Step 2: 观察者

观察者实现Observer接口，里面只有一个update方法，可以说是一个函数式接口，读者可以回看一下源码中的这一段，应该知道这个方法的作用了，这是观察者对被观察者通知做出的反应

```
((Observer) arrLocal[i]).update(this, arg);
```

```
public class Watcher implements Observer {
   @Override
    public void update(Observable o, Object arg) {
        Target target = (Target) o;
        System.out.println("I am be notified by " + target.getName() + ", message is " + arg);
    }}
```
### Step 3: 验证

```
public static void main(String[] args) {
        Target target = new Target();

        Watcher foo = new Watcher();
        Watcher bar = new Watcher();

        // 注册
        target.addObserver(foo);
        target.addObserver(bar);

        // 目标发生改变, 自动通知监视器，并调用update方法
        target.setName("Jim");

        // 移除监视器
        target.deleteObserver(bar);
        target.setName("Kim");
    }
```
### 控制台输出

```
I am be notified by Jim, message is name has been changed, now is Jim
I am be notified by Jim, message is name has been changed, now is Jim
I am be notified by Kim, message is name has been changed, now is Kim

```

### 结论

	
1. 第一次setName通知了两个观察者，然后移除了bar观察者，下一次通知就只有一个观察者收到了
2. 现在想想以前用过的vue，应该也使用到了观察者模式

## 心得

```	
Java中解耦是很重要的一件事，小到类，大到多个系统，以我愚见，都是一种思想

增加一个中间层，可以是一个接口，一个变量，一个中间件，一份文件，
这个中间层有很多名词，注册中心，负载均衡，代理，委托
```


